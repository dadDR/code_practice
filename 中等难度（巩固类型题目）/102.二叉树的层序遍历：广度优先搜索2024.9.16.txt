/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {
    //层序遍历：使用队列结构
    //C语言模拟队列
    struct TreeNode* node;//定义选中的二叉树节点
    struct TreeNode* queue[2000];
    int font , rear; //队首和队尾
    font = 0;
    rear = 0;
    //返回值（二维数组）
    int** ans = (int**)malloc(sizeof(int*) * 2000);
    *returnColumnSizes =(int*)malloc(sizeof(int)* 2000) ;
    *returnSize = 0;//初始化行数
    if(root == NULL){
        return NULL;
    }
    //先让根节点入队
    queue[rear++] = root;
    while(font < rear)//遍历条件：队列不为空
    {
        
        int len = rear -font;//每层的长度
        int* level = (int*)malloc(sizeof(int) * len);//存储这一层的元素
        (*returnColumnSizes)[(*returnSize)] = len;//记录每层的长度
        for(int i = 0 ;i < len ; i++)
        {//将每层的节点置入,同时将置入节点的下一层节点也置入队列
            node = queue[font++];//从队列中取出节点
            level[i] = node->val;
            if(node->left != NULL)
            {
                queue[rear++] = node->left;
            }
            if(node->right != NULL)
            {
                queue[rear++] = node->right;
            }

        }
        //这一层元素置入完成后,将其结果赋值给数组
        ans[(*returnSize)++] = level;
    }
    return ans;
}